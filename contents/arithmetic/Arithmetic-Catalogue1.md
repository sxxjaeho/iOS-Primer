
   * [剑指OFFER 名企面试官精讲典型编程题-部分算法题解](#剑指OFFER-名企面试官精讲典型编程题-部分算法题解)
      * [1.赋值运算符函数](#1赋值运算符函数)
      * [2.实现 Singleton 模式](#2实现-singleton-模式)
      * [3.数组中重复的数字✅](#3数组中重复的数字)
      * [4.二维数组中的查找✅](#4二维数组中的查找)
      * [5.替换空格✅](#5替换空格)
      * [6.从尾到头打印链表](#6从尾到头打印链表)
      * [7.重建二叉树](#7重建二叉树)
      * [8.二叉树的下一个节点](#8二叉树的下一个节点)
      * [9.用两个栈实现队列](#9用两个栈实现队列)
      * [10.斐波那契函数✅](#10斐波那契函数)
      * [11.旋转数组的最小数字](#11旋转数组的最小数字)
      * [12.矩阵中的路径](#12矩阵中的路径)
      * [13.机器人的运动范围](#13机器人的运动范围)
      * [14.剪绳子](#14剪绳子)
      * [15.二进制中 1 的个数](#15二进制中-1-的个数)
      * [16.数值的整数次方](#16数值的整数次方)
      * [17.打印从 1 到最大的 n 位数](#17打印从-1-到最大的-n-位数)
      * [18.删除链表的节点](#18删除链表的节点)
      * [19.正则表达式匹配](#19正则表达式匹配)
      * [20.表示数值的字符串](#20表示数值的字符串)
      * [21.调整数组顺序使奇数位于偶数前面](#21调整数组顺序使奇数位于偶数前面)
      * [22.链表中倒数第 k 个节点](#22链表中倒数第-k-个节点)
      * [23.链表中环的入口节点](#23链表中环的入口节点)
      * [24.反转链表✅](#24反转链表)
      * [25.合并两个排序的链表✅](#25合并两个排序的链表)
      * [26.树的子结构](#26树的子结构)
      * [27.二叉树的镜像](#27二叉树的镜像)
      * [28.对称的二叉树✅](#28对称的二叉树)
      * [29.顺时针打印矩阵✅](#29顺时针打印矩阵)
      * [30.包含 min 函数的栈](#30包含-min-函数的栈)
      * [31.栈的压入、弹出序列](#31栈的压入弹出序列)
      * [32.从上到下打印二叉树](#32从上到下打印二叉树)
      * [33.二叉搜索树的后续遍历序列](#33二叉搜索树的后续遍历序列)
      * [34.二叉树中和为某一值的路径](#34二叉树中和为某一值的路径)
      * [35.复杂链表的复制](#35复杂链表的复制)
      * [36.二叉搜索树与双向链表](#36二叉搜索树与双向链表)
      * [37.序列化二叉树](#37序列化二叉树)
      * [38.字符串的排列](#38字符串的排列)
      * [39.数组中出现次数超过一半的数字](#39数组中出现次数超过一半的数字)
      * [40.最小的 k 个数](#40最小的-k-个数)
      * [41.数据流中的中位数✅](#41数据流中的中位数)
      * [42.连续子数组的最大和✅](#42连续子数组的最大和)
      * [43.1 ~ n 整数中 1 出现的次数](#431--n-整数中-1-出现的次数)
      * [44.数字序列中某一位的数字](#44数字序列中某一位的数字)
      * [45.把数组排成最小的数](#45把数组排成最小的数)
      * [46.把数字翻译成字符串](#46把数字翻译成字符串)
      * [47.礼物的最大价值](#47礼物的最大价值)
      * [48.最长不含重复字符的子字符串](#48最长不含重复字符的子字符串)
      * [49.丑数](#49丑数)
      * [50.第一个只出现一次的字符✅](#50第一个只出现一次的字符)
      * [51.数组中的逆序对](#51数组中的逆序对)
      * [52.两个链表的第一个公共节点](#52两个链表的第一个公共节点)
      * [53.在排序数组中查找数字](#53在排序数组中查找数字)
      * [54.二叉搜索树的第 k 大节点](#54二叉搜索树的第-k-大节点)
      * [55.二叉树深度✅](#55二叉树深度)
      * [56.数组中数字出现的次数](#56数组中数字出现的次数)
      * [57.和为 s 的数字✅](#57和为-s-的数字)
      * [58.翻转字符串✅](#58翻转字符串)
      * [59.队列的最大值](#59队列的最大值)
      * [60.n 个骰子的点数](#60n-个骰子的点数)
      * [61.扑克牌中的顺子](#61扑克牌中的顺子)
      * [62.圆圈中最后剩下的数字](#62圆圈中最后剩下的数字)
      * [63.股票的最大利润](#63股票的最大利润)
      * [64.求 1+2...+n](#64求-12n)
      * [65.不用加减乘除做加法](#65不用加减乘除做加法)
      * [66.构建乘积数组](#66构建乘积数组)
      * [67.把字符串转换成整数](#67把字符串转换成整数)
      * [68.树中两个节点的最低公共祖先](#68树中两个节点的最低公共祖先)

# 剑指OFFER 名企面试官精讲典型编程题-部分算法题解
## 1.赋值运算符函数


## 2.实现 Singleton 模式


## 3.数组中重复的数字

[数组中重复的数字.playground](https://github.com/sxxjaeho/iOS-Primer/blob/master/contents/arithmetic/code/找出数组中重复的数字.playground)

题目：在一个长度为n的数组里的所有数字都在0到n-1的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。例如，如果输入长度为7的数组{2, 3, 1, 0, 2, 5, 3}，那么对应的输出是重复的数字2或者3。

```
func duplicate(_ nums: [Int]) -> Int? {
    var nums = nums
    for index in 0..<nums.count {
        while nums[index] != index {
            if nums[index] == nums[nums[index]] {
                return nums[index]
            }
            (nums[index], nums[nums[index]]) = (nums[nums[index]], nums[index])
        }
    }
    return nil
}

let nums =  [2, 3, 1, 0, 2, 5, 3]
if let result = duplicate(nums) {
    print(result)
} else {
    print("Not found")
}
```

**时间复杂度：O(n) 空间复杂度：O(1)**

***

## 4.二维数组中的查找

[二维数组中的查找.playground](https://github.com/sxxjaeho/iOS-Primer/blob/master/contents/arithmetic/code/二维数组中的查找.playground)

题目：在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。

```
func find(_ matrix: [[Int]], _ num: Int) -> Bool {
    var row = 0
    var column = matrix.count - 1
    while column <= matrix[0].count - 1 && row >= 0 {
        if matrix[row][column] > num {
            column -= 1
        } else if matrix[row][column] < num {
            row += 1
        } else {
            return true
        }
    }
    return false
}

let nums = [[1, 2, 8, 9], [2, 4, 9 , 12], [4, 7, 10, 13], [6, 8, 11, 15]]
print(find(nums, 7))
```

**时间复杂度：O(n+m)**

***

## 5.替换空格

[替换空格.playground](https://github.com/sxxjaeho/iOS-Primer/blob/master/contents/arithmetic/code/替换空格.playground)

题目：请实现一个函数，把字符串中的每个空格替换成"%20"。例如输入“We are happy.”，则输出“We%20are%20happy.”

```
func replaceBlank(_ string: String) -> String? {
    let characters = Array(string)
    guard characters.count != 0 else {
        return nil
    }
    
    var numberOfBlank = 0
    for character in characters {
        if character == " " {
            numberOfBlank += 1
        }
    }
    
    if numberOfBlank == 0 {
        return string
    }
    
    let newLength = characters.count + numberOfBlank * 2
    
    var indexOfOriginal = characters.count - 1
    var indexOfNew = newLength - 1
    
    var resultArray = [Character](repeating: " ", count: newLength)
    
    while indexOfOriginal >= 0 {
        
        let start = string.index(string.startIndex, offsetBy: indexOfOriginal)
        let end = string.index(string.startIndex, offsetBy: indexOfOriginal + 1)
        let character = Character(String(string[start..<end]))
        
        if character == " " {
            resultArray[indexOfNew-2...indexOfNew] = ["%", "2", "0"]
            indexOfNew -= 2
        } else {
            resultArray[indexOfNew] = character
        }
        
        indexOfOriginal -= 1
        indexOfNew -= 1
    }
    
    return String(resultArray)
}

let string = "We are happy."
print(replaceBlank(string) ?? "")
```

**时间复杂度：O(n)**

***

## 6.从尾到头打印链表


## 7.重建二叉树


## 8.二叉树的下一个节点


## 9.用两个栈实现队列


## 10.斐波那契函数

[斐波那契函数.playground](https://github.com/sxxjaeho/iOS-Primer/blob/master/contents/arithmetic/code/斐波那契函数.playground)

题目：写一个函数，输入n，求斐波那契（Fibonacci）数列的第n项。

```
// 递归，效率低
//func fibonacciRecursion(_ num : Int) -> Int {
//    if num <= 0 {
//        return 0
//    }
//    if num == 1 {
//        return 1
//    }
//    return fibonacciRecursion(num - 1) + fibonacciRecursion(num - 2)
//}

// 循环，更实用
func fibonacciLoop(_ num : Int) -> Int {
    if num <= 0 {
        return 0
    }
    var (prev, curr) = (0, 1)
    for _ in 1..<num {
        (prev, curr) = (curr, curr + prev)
    }
    return curr
}

// print(fibonacciRecursion(6))
print(fibonacciLoop(6))
```

**时间复杂度：O(n) 空间复杂度：O(1)**

***

## 11.旋转数组的最小数字


## 12.矩阵中的路径


## 13.机器人的运动范围


## 14.剪绳子


## 15.二进制中 1 的个数


## 16.数值的整数次方


## 17.打印从 1 到最大的 n 位数


## 18.删除链表的节点


## 19.正则表达式匹配


## 20.表示数值的字符串


## 21.调整数组顺序使奇数位于偶数前面


## 22.链表中倒数第 k 个节点


## 23.链表中环的入口节点


## 24.反转链表

[反转链表.playground](https://github.com/sxxjaeho/iOS-Primer/blob/master/contents/arithmetic/code/反转链表.playground)

题目：定义一个函数，输入一个链表的头结点，反转该链表并输出反转后链表的头结点。链表节点定义如下：

```
class ListNode {
    var value: Int
    var next: ListNode?
    
    init(_ value: Int) {
        self.value = value
    }
    
    func next(_ value: Int) -> ListNode {
        let node = ListNode(value)
        next = node
        return node
    }
}

func reverseList(_ head: ListNode?) -> ListNode? {
    var reversedHead: ListNode? = nil
    var node: ListNode? = head
    var prev: ListNode? = nil
    while node != nil {
        let next = node?.next
        if next == nil {
            reversedHead = node
        }
        node?.next = prev
        prev = node
        node = next
    }
    return reversedHead
}

func traverseList(_ head : ListNode?) {
    var node = head
    while node != nil {
        print(node?.value ?? 0)
        node = node?.next
    }
}


let head = ListNode(1)
head.next(2).next(3).next(4).next(5)
print("原链表:")
traverseList(head)

let newHead = reverseList(head)
print("反转链表:")
traverseList(newHead)
```   

***

## 25.合并两个排序的链表

[合并两个排序的链表.playground](https://github.com/sxxjaeho/iOS-Primer/blob/master/contents/arithmetic/code/合并两个排序的链表.playground)

题目：输入两个递增排序的链表，合并这两个链表并使新链表中的结点仍然是按照递增排序的。例如输入如下链表1和链表2，则合并之后的升序链表如链3所示。链表节点定义如下：
链表1：1 -> 3 -> 5 -> 7
链表2：2 -> 4 -> 6 -> 8
链表3：1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7 -> 8

```
class ListNode {
    var value: Int
    var next: ListNode?

    init(_ value: Int) {
        self.value = value
    }

    func next(_ value: Int) -> ListNode {
        let node = ListNode(value)
        next = node
        return node
    }
}

func merge(_ head1: ListNode?, _ head2: ListNode?) -> ListNode? {
    if head1 == nil {
        return head2
    } else if head2 == nil {
        return head1
    }
    var newHead: ListNode? = nil
    if head1!.value < head2!.value {
        newHead = head1
        newHead?.next = merge(head1?.next, head2)
    } else {
        newHead = head2
        newHead?.next = merge(head1, head2?.next)
    }
    return newHead
}

func traverseList(_ head : ListNode?) {
    var node = head
    while node != nil {
        print(node?.value ?? 0)
        node = node?.next
    }
}

print("链表1:")
let head1 = ListNode(1)
head1.next(3).next(5).next(7)
traverseList(head1)

print("链表2:")
let head2 = ListNode(2)
head2.next(4).next(6).next(8)
traverseList(head2)

let newHead = merge(head1, head2)
print("合并链表:")
traverseList(newHead)
```

***

## 26.树的子结构


## 27.二叉树的镜像


## 28.对称的二叉树
题目：请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。

[对称的二叉树.playground](https://github.com/sxxjaeho/iOS-Primer/blob/master/contents/arithmetic/code/对称的二叉树.playground)

```
class BinaryTreeNode {
    var left: BinaryTreeNode?
    var right: BinaryTreeNode?
    var value: Int
    
    init(value: Int, left: BinaryTreeNode?, right: BinaryTreeNode?) {
        self.value = value
        self.left = left
        self.right = right
    }
}

func isSymmetrical(_ root: BinaryTreeNode?) -> Bool{
    return isSymmetrical(root, root)
}

func isSymmetrical(_ node1: BinaryTreeNode?, _ node2: BinaryTreeNode?) -> Bool {
    if node1 == nil && node2 == nil {
        return true
    }
    if node1 == nil || node2 == nil {
        return false
    }
    if node1?.value != node2?.value {
        return false
    }
    
    return isSymmetrical(node1?.left, node2?.right) &&
            isSymmetrical(node1?.right, node2?.left)
}

let root = BinaryTreeNode(value: 8, left: BinaryTreeNode(value: 6, left: BinaryTreeNode(value: 5, left: nil, right: nil), right: BinaryTreeNode(value: 7, left: nil, right: nil)), right: BinaryTreeNode(value: 6, left: BinaryTreeNode(value: 7, left: nil, right: nil), right: BinaryTreeNode(value: 5, left: nil, right: nil)))
let root1 = BinaryTreeNode(value: 7, left: BinaryTreeNode(value: 7, left: BinaryTreeNode(value: 7, left: nil, right: nil), right: BinaryTreeNode(value: 7, left: nil, right: nil)), right: BinaryTreeNode(value: 7, left: BinaryTreeNode(value: 7, left: nil, right: nil), right: nil))
print(isSymmetrical(root))
print(isSymmetrical(root1))
```

***

## 29.顺时针打印矩阵
题目：输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。

[顺时针打印矩阵.playground](https://github.com/sxxjaeho/iOS-Primer/blob/master/contents/arithmetic/code/顺时针打印矩阵.playground)

```
func spiralOrder(_ matrix: [[Int]]) -> [Int] {
    guard matrix.count != 0 else {
        return []
    }
    
    var left = 0
    var top = 0
    var right = matrix[top].count - 1
    var bottom = matrix.count - 1
    var result = [Int]()
    
    while true {
        if right < left { break }
        for i in (left...right) {
            result.append(matrix[top][i])
        }
        top += 1
        
        if top > bottom { break }
        for i in (top...bottom) {
            result.append(matrix[i][right])
        }
        right -= 1
        
        if right < left { break }
        for i in (left...right).reversed() {
            result.append(matrix[bottom][i])
        }
        bottom -= 1
        
        if top > bottom { break }
        for i in (top...bottom).reversed() {
            result.append(matrix[i][left])
        }
        left += 1
    }
    return result
}

print(spiralOrder([[1,2,3], [4,5,6], [7,8,9]]))
```

***

## 30.包含 min 函数的栈


## 31.栈的压入、弹出序列


## 32.从上到下打印二叉树


## 33.二叉搜索树的后续遍历序列


## 34.二叉树中和为某一值的路径


## 35.复杂链表的复制


## 36.二叉搜索树与双向链表


## 37.序列化二叉树


## 38.字符串的排列


## 39.数组中出现次数超过一半的数字


## 40.最小的 k 个数


## 41.数据流中的中位数

[数据流中的中位数.playground](https://github.com/sxxjaeho/iOS-Primer/blob/master/contents/arithmetic/code/数据流中的中位数.playground)

题目：如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。

```
var max = Heap<Int>(sort: >)
var min = Heap<Int>(sort: <)

func getMedian(_ nums: [Int]) -> Double? {
    if nums.count == 0 { return nil }

    for num in nums {
        if max.isEmpty || num <= max.peek()! {
           max.insert(num)
        } else {
           min.insert(num)
        }
        balance()
    }
    let size = min.count + max.count
    if nums.count % 2 == 0 {
        return Double((min.peek()! + max.peek()!)) / 2
    } else {
        return Double(max.peek()!)
    }
}

func balance() {
    if min.count < max.count - 1 {
        min.insert(max.remove()!)
    }
    if max.count < min.count {
        max.insert(min.remove()!)
    }
}

let array = [5, 8, 1, 3, 6, 2, 9];
print(getMedian(array) ?? 0)
```

**时间复杂度：O(logn) 空间复杂度：O(n)**

***

## 42.连续子数组的最大和

[连续子数组的最大和.playground](https://github.com/sxxjaeho/iOS-Primer/blob/master/contents/arithmetic/code/连续子数组的最大和.playground)

题目：输入一个整型数组，数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。

要求时间复杂度为O(n)。

示例：

```
输入: nums = [-2,1,-3,4,-1,2,1,-5,4]
输出: 6
解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。
```

```
func maxSubArray(_ nums: [Int]) -> Int {
    guard nums.count > 0 else {
        return 0
    }
    var dp = nums
    var maxSum = nums[0]
    for i in 1..<nums.count {
        dp[i] = max(dp[i-1], 0) + nums[i]
        maxSum = max(maxSum, dp[i])
    }
    return maxSum
}
```

**时间复杂度：O(n) 空间复杂度：O(n)**

***

## 43.1 ~ n 整数中 1 出现的次数


## 44.数字序列中某一位的数字


## 45.把数组排成最小的数


## 46.把数字翻译成字符串


## 47.礼物的最大价值


## 48.最长不含重复字符的子字符串


## 49.丑数


## 50.第一个只出现一次的字符

[字符串中第一个只出现一次的字符.playground](https://github.com/sxxjaeho/iOS-Primer/blob/master/contents/arithmetic/code/字符串中第一个只出现一次的字符.playground)

题目：字符串中第一个只出现一次的字符。
在字符串中找出第一个只出现一次的字符。如输入“abaccdeff”，则输出“b”。

```
// 题目：字符串中第一个只出现一次的字符。
// 在字符串中找出第一个只出现一次的字符。如输入“abaccdeff”，则输出“b”

func firstNotRepeatingChar(_ string: String) -> Character? {
    let chars = Array(string)
    var dictionary = [Character: Int]()
    for char in chars {
        if dictionary[char] == nil {
            dictionary[char] = 1
        } else {
            dictionary[char]! += 1
        }
    }
    for char in chars {
        if dictionary[char]! == 1 {
            return char
        }
    }
    return nil
}

print(firstNotRepeatingChar("abaccdeff") ?? "")
```

***

## 51.数组中的逆序对


## 52.两个链表的第一个公共节点


## 53.在排序数组中查找数字


## 54.二叉搜索树的第 k 大节点


## 55.二叉树深度

[二叉树深度.playground](https://github.com/sxxjaeho/iOS-Primer/blob/master/contents/arithmetic/code/二叉树深度.playground)

题目：输入一棵二叉树的根结点，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。

```
class BinaryTreeNode {
    var left: BinaryTreeNode?
    var right: BinaryTreeNode?
    var value: Int
    
    init(value: Int, left: BinaryTreeNode?, right: BinaryTreeNode?) {
        self.value = value
        self.left = left
        self.right = right
    }
}

func treeDepth(_ root: BinaryTreeNode?) -> Int {
    guard root != nil else {
        return 0
    }
    let left = treeDepth(root?.left)
    let right = treeDepth(root?.right)
    return max(left, right) + 1
}

let root = BinaryTreeNode(value: 1, left: BinaryTreeNode(value: 2, left: BinaryTreeNode(value: 4, left: nil, right: nil)
    , right: BinaryTreeNode(value: 5, left: BinaryTreeNode(value: 7, left: nil, right: nil), right: nil)), right: BinaryTreeNode(value: 3, left: nil, right: BinaryTreeNode(value: 6, left: nil, right: nil)))
print(treeDepth(root))
```

***

## 56.数组中数字出现的次数


## 57.和为 s 的数字

[和为s的数字.playground](https://github.com/sxxjaeho/iOS-Primer/blob/master/contents/arithmetic/code/和为s的数字.playground)

题目：输入一个递增排序的数组和一个数字 s，在数组中查找两个数，使得它们的和正好是 s。如果有多对数字的和等于 s，输出任意一对即可。

```
func findNumbersWithSum(_ nums: [Int], _ sum: Int) -> (num1: Int, num2: Int)? {
    if nums.count < 2 {
        return nil
    }
    
    var ahead = nums.count - 1
    var behind = 0
    
    while ahead > behind {
        let curSum = nums[ahead] + nums[behind]
        if curSum == sum {
            return (nums[behind], nums[ahead])
        } else if curSum > sum {
            ahead -= 1
        } else {
            behind += 1
        }
    }
    return nil
}

let result = findNumbersWithSum([1, 2, 4, 7, 11, 15], 10)
if result != nil {
    print(result!)
} else {
    print("未找到符合条件的两个数")
}
```

***

## 58.翻转字符串

[翻转字符串.playground](https://github.com/sxxjaeho/iOS-Primer/blob/master/contents/arithmetic/code/翻转字符串.playground)

题目：输入一个英文句子，翻转句子中单词的顺序，但单词内字符的顺序不变。为简单起见，标点符号和普通字母一样处理。例如输入字符串"I am a student."，则输出"student. a am I"。

```
func reverseWords(_ s: String) -> String {
    if s.isEmpty {
        return ""
    }
    var chars = Array(trimmingCharacters(s))    
    var start = 0
    reverse(&chars, 0, chars.count - 1)
    for i in 0...chars.count - 1 {
        if i == chars.count - 1 || chars[i + 1] == " " {
            reverse(&chars, start, i)
            start = i + 2
        }
    }
    return String(chars)
}

func trimmingCharacters(_ s: String) -> String {
    return s.trimmingCharacters(in: .whitespaces).components(separatedBy: .whitespaces).filter { $0 != "" }.joined(separator: " ")
}

func reverse(_ chars: inout Array<Character>, _ begin: Int, _ end: Int) {
    var begin = begin
    var end = end
    
    while begin < end {
        chars.swapAt(begin, end)
        begin += 1
        end -= 1
    }
}

print(reverseWords("  hello  world  "))
```

***

## 59.队列的最大值


## 60.n 个骰子的点数


## 61.扑克牌中的顺子


## 62.圆圈中最后剩下的数字


## 63.股票的最大利润


## 64.求 1+2+...+n


## 65.不用加减乘除做加法


## 66.构建乘积数组


## 67.把字符串转换成整数


## 68.树中两个节点的最低公共祖先


